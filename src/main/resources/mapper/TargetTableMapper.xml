<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.kt.yaap.mig_batch.mapper.TargetTableMapper">


    <!-- INFORMATION_SCHEMA에서 모든 Primary Key 컬럼명 조회 (복합키 지원) -->
    <select id="selectPrimaryKeyColumns" resultType="string">
        SELECT kcu.column_name
        FROM information_schema.table_constraints tc
        JOIN information_schema.key_column_usage kcu 
            ON tc.constraint_name = kcu.constraint_name
            AND tc.table_schema = kcu.table_schema
        WHERE tc.table_schema = COALESCE(#{params.schemaName}, 'public')
          AND tc.table_name = #{params.tableName}
          AND tc.constraint_type = 'PRIMARY KEY'
        ORDER BY kcu.ordinal_position
    </select>


    <!-- 대상 테이블에서 PK와 모든 대상 컬럼을 스트리밍 방식으로 조회 (Cursor 사용) -->
    <!-- 
        스트리밍 방식의 장점:
        - 메모리 효율: 한 번에 하나씩만 읽어서 메모리 사용량 최소화
        - 빠른 시작: 초기화 시간 단축 (전체 조회 대비 20~30초 단축)
        - 대용량 데이터 처리: OOM 위험 없이 처리 가능
        
        fetchSize: DB에서 한 번에 가져올 레코드 수
        - 1000: 일반적인 권장값
        - 10000: 대용량 데이터에 적합
    -->
    <select id="selectAllTargetColumnsStreaming" resultType="java.util.HashMap" fetchSize="1000">
        SELECT 
            <foreach collection="params.pkColumnNames" item="pkCol" separator=",">
                ${pkCol} AS "pk_${pkCol}"
            </foreach>
            <foreach collection="params.targetColumnNames" item="colName">
                ,${colName}
            </foreach>
        FROM ${params.tableName}
        ORDER BY 
            <foreach collection="params.pkColumnNames" item="pkCol" separator=",">
                ${pkCol}
            </foreach>
    </select>

    <!-- 대상 테이블 벌크 업데이트 (여러 레코드를 한 번의 SQL로 처리, 단일키/복합키 통일 처리) -->
    <!-- 
        성능 최적화: PostgreSQL의 UPDATE ... FROM (VALUES ...) 방식 사용
        - 3500건 처리 시: 3500개 SQL → 1개 SQL (약 3~5배 성능 개선 예상)
        - SQL 파싱: 3500회 → 1회
        - 네트워크 왕복: 3500회 → 1회
        
        주의: 모든 레코드는 동일한 컬럼 세트를 업데이트해야 함 (같은 테이블이므로 보통 동일)
    -->
    <update id="bulkUpdateTargetRecords">
        UPDATE ${params.tableName} AS t
        SET
        <!-- 각 컬럼별로 SET 절 생성 (원본 컬럼만 업데이트) -->
        <!-- allColumnNames: 업데이트할 모든 컬럼명 리스트 -->
        <!-- records: 각 레코드는 {pkValues, columnValues} 포함 -->
        <!-- columnValues: Map 형태로 {columnName: {encryptedValue}} -->
        <foreach collection="params.allColumnNames" item="colName" separator=",">
            ${colName} = v.${colName}
        </foreach>
        FROM (VALUES
            <foreach collection="params.records" item="record" separator=",">
                (<foreach collection="params.pkColumnNames" item="pkCol" separator=",">
                    #{record.pkValues[${pkCol}]}
                </foreach>
                <foreach collection="params.allColumnNames" item="colName">
                    ,#{record.columnValues[${colName}].encryptedValue}
                </foreach>)
            </foreach>
        ) AS v(<foreach collection="params.pkColumnNames" item="pkCol" separator=",">pk_${pkCol}</foreach>
        <foreach collection="params.allColumnNames" item="colName">
            ,${colName}
        </foreach>)
        WHERE 
            <foreach collection="params.pkColumnNames" item="pkCol" separator=" AND ">
                t.${pkCol} = v.pk_${pkCol}
            </foreach>
    </update>


</mapper>

